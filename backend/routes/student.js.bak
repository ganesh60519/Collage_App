const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const db = require('../db');
const auth = require('../middleware/auth');

// Register student
router.post('/register', async (req, res) => {
  try {
    const { name, email, password, branch } = req.body;

    // Check if user already exists
    const [existingUsers] = await db.execute('SELECT * FROM students WHERE email = ?', [email]);
    if (existingUsers.length > 0) {
      return res.status(400).json({ error: 'Email already registered' });
    }

    const hashedPassword = await bcrypt.hash(password, 8);

    const [result] = await db.execute(
      'INSERT INTO students (name, email, password, branch, profile_edit) VALUES (?, ?, ?, ?, ?)',
      [name, email, hashedPassword, branch, false]
    );

    res.status(201).json({ success: true, id: result.insertId });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed. Please try again.' });
  }
});

// Login student
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const [rows] = await db.execute('SELECT * FROM students WHERE email = ?', [email]);

    if (rows.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const student = rows[0];
    const isMatch = await bcrypt.compare(password, student.password);

    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign(
      { id: student.id, role: 'student' },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    res.json({ token, role: 'student' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Get student profile
router.get('/profile', auth, async (req, res) => {
  try {
    const [rows] = await db.execute(
      'SELECT id, name, email, branch, profile_edit FROM students WHERE id = ?',
      [req.user.id]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Student not found' });
    }

    res.json(rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get student tasks
router.get('/tasks', auth, async (req, res) => {
  try {
    const [tasks] = await db.execute(
      'SELECT t.* FROM tasks t WHERE t.assigned_to = ? AND t.assigned_role = "student"',
      [req.user.id]
    );
    res.json(tasks || []);
  } catch (error) {
    console.error('Error fetching tasks:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get student tickets
router.get('/tickets', auth, async (req, res) => {
  try {
    const [tickets] = await db.execute(
      'SELECT * FROM tickets WHERE raised_by = ?',
      [req.user.id]
    );
    res.json(tickets || []);
  } catch (error) {
    console.error('Error fetching tickets:', error);
    res.json([]);
  }
});

// Create new ticket
router.post('/tickets', auth, async (req, res) => {
  try {
    const { subject, description } = req.body;
    const [result] = await db.execute(
      'INSERT INTO tickets (subject, description, raised_by, role, status) VALUES (?, ?, ?, "student", "open")',
      [subject, description, req.user.id]
    );
    res.status(201).json({ success: true, ticket_id: result.insertId });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// Create profile update ticket
router.post('/profile-update-ticket', auth, async (req, res) => {
  try {
    const { subject, description, type, requested_updates } = req.body;

    // Set profile_edit to true for the student
    await db.execute(
      'UPDATE students SET profile_edit = ? WHERE id = ?',
      [true, req.user.id]
    );

    // Convert requested_updates to string if it's an object
    const updatesString = typeof requested_updates === 'object' ?
      JSON.stringify(requested_updates) :
      requested_updates;

    // Create ticket
    const [result] = await db.execute(
      'INSERT INTO tickets (subject, description, type, raised_by, role, status, requested_updates) VALUES (?, ?, ?, ?, "student", "pending", ?)',
      [subject, description, type, req.user.id, updatesString]
    );

    res.status(201).json({ message: 'Ticket created successfully', ticketId: result.insertId });
  } catch (error) {
    console.error('Error in profile-update-ticket route:', error);
    res.status(500).json({ message: 'Failed to create ticket', error: error.message });
  }
});

// Update student profile after approval
router.put('/profile', auth, async (req, res) => {
  try {
    const { ticket_id, updates } = req.body;

    // Check if ticket exists and is approved
    const [tickets] = await db.execute(
      'SELECT * FROM tickets WHERE id = ? AND status = "approved" AND type = "profile_update"',
      [ticket_id]
    );

    if (tickets.length === 0) {
      return res.status(403).json({ error: 'No approved ticket found for profile update' });
    }

    // Validate updates object
    if (!updates || typeof updates !== 'object' || Object.keys(updates).length === 0) {
      return res.status(400).json({ error: 'No updates provided' });
    }

    // Define allowed fields to prevent SQL injection
    const allowedFields = ['name', 'email', 'branch'];
    const updateFields = Object.keys(updates).filter(field => allowedFields.includes(field));

    if (updateFields.length === 0) {
      return res.status(400).json({ error: 'No valid fields to update' });
    }

    // Build the SET clause dynamically
    const setClause = updateFields.map(field => `${field} = ?`).join(', ');
    const query = `UPDATE students SET ${setClause}, profile_edit = ? WHERE id = ?`;

    // Collect values for the placeholders
    const values = [...updateFields.map(field => updates[field]), false, req.user.id];

    // Execute the update query
    const [result] = await db.execute(query, values);

    // Mark ticket as completed
    await db.execute(
      'UPDATE tickets SET status = "completed" WHERE id = ?',
      [ticket_id]
    );

    res.json({ success: true });
  } catch (error) {
    console.error('Error updating profile:', error);
    res.status(500).json({ error: error.message });
  }
});

// Resume routes

// Test resume endpoint
router.get('/resume-test', async (req, res) => {
  try {
    res.json({ message: 'Resume test endpoint working' });
  } catch (error) {
    console.error('Error in test endpoint:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get student resume
router.get('/resume', auth, async (req, res) => {
  try {
    const [rows] = await db.execute(
      'SELECT * FROM resumes WHERE student_id = ?',
      [req.user.id]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Resume not found', exists: false });
    }

    // Get student information to include with resume
    const [studentInfo] = await db.execute(
      'SELECT name, email, branch FROM students WHERE id = ?',
      [req.user.id]
    );

    if (studentInfo.length === 0) {
      return res.status(404).json({ error: 'Student information not found' });
    }

    // Combine resume and student info
    const resumeData = {
      ...rows[0],
      studentInfo: studentInfo[0],
      exists: true
    };

    res.json(resumeData);
  } catch (error) {
    console.error('Error fetching resume:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create or update student resume
router.post('/resume', auth, async (req, res) => {
  try {
    const { education, skills, experience, projects, certifications, achievements } = req.body;

    // Check if resume already exists
    const [existingResume] = await db.execute(
      'SELECT id FROM resumes WHERE student_id = ?',
      [req.user.id]
    );

    if (existingResume.length > 0) {
      // Update existing resume
      await db.execute(
        'UPDATE resumes SET education = ?, skills = ?, experience = ?, projects = ?, certifications = ?, achievements = ? WHERE student_id = ?',
        [education, skills, experience, projects, certifications, achievements, req.user.id]
      );
      res.json({ success: true, message: 'Resume updated successfully' });
    } else {
      // Create new resume
      await db.execute(
        'INSERT INTO resumes (student_id, education, skills, experience, projects, certifications, achievements) VALUES (?, ?, ?, ?, ?, ?, ?)',
        [req.user.id, education, skills, experience, projects, certifications, achievements]
      );
      res.status(201).json({ success: true, message: 'Resume created successfully' });
    }
  } catch (error) {
    console.error('Error creating/updating resume:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get formatted resume for viewing
router.get('/resume/view', auth, async (req, res) => {
  try {
    // Get resume data
    const [rows] = await db.execute(
      'SELECT * FROM resumes WHERE student_id = ?',
      [req.user.id]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Resume not found', exists: false });
    }

    // Get student information
    const [studentInfo] = await db.execute(
      'SELECT name, email, roll_number, department, year_of_study FROM students WHERE id = ?',
      [req.user.id]
    );

    if (studentInfo.length === 0) {
      return res.status(404).json({ error: 'Student information not found' });
    }

    // Combine resume and student info
    const resumeData = {
      ...rows[0],
      studentInfo: studentInfo[0],
      exists: true
    };

    res.json({
      success: true,
      resume: resumeData,
      message: 'Resume retrieved successfully'
    });
  } catch (error) {
    console.error('Error retrieving formatted resume:', error);
    res.status(500).json({ error: error.message });
  }
});

// Generate a shareable link for the resume
router.get('/resume/share', auth, async (req, res) => {
  try {
    // Check if resume exists
    const [rows] = await db.execute(
      'SELECT id FROM resumes WHERE student_id = ?',
      [req.user.id]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Resume not found', exists: false });
    }

    // Generate a unique share ID (you could use a more sophisticated method in production)
    const shareId = Buffer.from(`${req.user.id}-${Date.now()}`).toString('base64');
    
    // In a production app, you would store this share ID in the database
    // For this example, we'll just return it
    
    // Create a shareable URL
    const shareUrl = `http://${process.env.HOST || 'localhost'}:3000/api/student/resume/public/${shareId}`;
    
    res.json({
      success: true,
      shareUrl,
      shareId,
      message: 'Resume share link generated successfully'
    });
  } catch (error) {
    console.error('Error generating share link:', error);
    res.status(500).json({ error: error.message });
  }
});

// Public endpoint to view a shared resume
router.get('/resume/public/:shareId', async (req, res) => {
  try {
    const { shareId } = req.params;
    
    // In a production app, you would validate the shareId against stored values
    // For this example, we'll decode it to get the student ID
    
    const decoded = Buffer.from(shareId, 'base64').toString('utf-8');
    const studentId = parseInt(decoded.split('-')[0]);
    
    if (isNaN(studentId)) {
      return res.status(400).json({ error: 'Invalid share link' });
    }
    
    // Get resume data
    const [rows] = await db.execute(
      'SELECT * FROM resumes WHERE student_id = ?',
      [studentId]
    );

    if (rows.length === 0) {
      return res.status(404).json({ error: 'Resume not found' });
    }

    // Get student information (limited for privacy)
    const [studentInfo] = await db.execute(
      'SELECT name, branch FROM students WHERE id = ?',
      [studentId]
    );

    if (studentInfo.length === 0) {
      return res.status(404).json({ error: 'Student information not found' });
    }

    // Combine resume and student info
    const resumeData = {
      ...rows[0],
      studentInfo: studentInfo[0]
    };

    res.json({
      success: true,
      resume: resumeData,
      message: 'Shared resume retrieved successfully'
    });
  } catch (error) {
    console.error('Error retrieving shared resume:', error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;